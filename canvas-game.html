<!DOCTYPE html>
<html>
<head>
	<title>Canvas Game!</title>
	<link rel="stylesheet" type="text/css" href="styles.css">

</head>
<body>
<div id="wrapper">
	<div id="Header">
		<h1>Goblin Slayer</h1>
		<div id="header-left">
			Content
		</div>
		<div id="header-right">
			
		</div>
	</div>
	<div id="game">
		<script type="text/javascript">
			// Create canvas tag with js.
			var canvas = document.createElement('canvas');
			// Create context for (Methods and properties)
			var context = canvas.getContext('2d');

			canvas.width = 512;
			canvas.height = 480;

			// Add to the DOM.
			document.body.appendChild(canvas);

			var backgroundImage = new Image();
			backgroundImage.src = "background.png";

			var speedModifier = .5; 

			var monsterSpeedModifier = 4.29;

			// Make the sword
			var sword = new Image();
			sword.src = "sword.png";
			var swordLocation = {
				x: 240,
				y: 226
			}

			// make a var for hero.
			var hero = new Image();
			hero.src = "hero.png";
			var heroLocation = {
				x:240,
				y:226
			}

			

			// Make a var for the monster.
			var monster = new Image();
			monster.src = "monster.png";
			var monsterLocation = {
				x:200,
				y:100,
				newX:200,
				newY:100
			}

			///////////////////////////

			// CANVAS PROPERTIES
			var ctx = canvas.getContext('2d');
			ctx.lineWidth = 50;
			ctx.strokeStyle = '#aaa';
			ctx.shadowOffsetX = 0;
			ctx.shadowOffsetY = 0;
			ctx.shadowBlur = 10;
			ctx.shadowColor = '#000';

			// CANVAS MATHS
			var x = heroLocation.x,
			    y = heroLocation.y,
			    radius = 100,
			    circum = Math.PI * 2,
			    start = Math.PI / 2, // Start position (top)
			    finish = 100, // Finish (in %)
			    curr = 0; // Current position (in %)

			// CANVAS ANIMATION

			// Enables browser-decided smooth animation (60fps)
			var raf =
			    window.requestAnimationFrame ||
			    window.mozRequestAnimationFrame ||
			    window.webkitRequestAnimationFrame ||
			    window.msRequestAnimationFrame;
			window.requestAnimationFrame = raf;

			// Animate function
			function animate(draw_to) {
			  // Clear off the canvas
			  ctx.clearRect(0, 0, canvas.width, canvas.height);
			  // ctx.clearRect(0, 0, width, height);
			  // Start over
			  ctx.beginPath();
			  // arc(x, y, radius, startAngle, endAngle, anticlockwise)
			  // Re-draw from the very beginning each time so there isn't tiny line spaces between each section (the browser paint rendering will probably be smoother too)
			  ctx.arc(x, y, radius, start, draw_to, false);
			  // Draw
			  ctx.stroke();
			  // Increment percent
			  curr++;
			  // Animate until end
			  if (curr < finish + 1) {
			    // Recursive repeat this function until the end is reached
			    requestAnimationFrame(function () {
			      animate(circum * curr / 10 + start);
			    }); 
			  }
			  animateSword();
			}


			///////////////////////////

			


			// An array to hold all keys down.
			var keysDown = [];

			addEventListener('keyup', function(event){
				delete keysDown[event.keyCode];

			});

			// Need a way to check for arrow keypresses.
			addEventListener('keydown', function(event){
				// if keyDown[39] is true, right arrow was pushed
				// if keyDown[40] is true, down arrow was pushed
				// if keyDown[37] is true, left arrow was pushed
				// if keyDown[48] is true, up arrow was pushed
				keysDown[event.keyCode] = true;
				// we know a key was pressed at this point.
				// what key did they press?
				// console.log(event.key);
				// if(event.key === 'ArrowDown'){
				// 	console.log('User pressed Down Arrow');
				// 	heroLocation.y += 10;
				// }
				// if(event.key === 'ArrowUp'){
				// 	console.log('User pressed Up Arrow');
				// 	heroLocation.y -= 10;
				// }
				// if(event.key === 'ArrowLeft'){
				// 	console.log('User pressed Left Arrow');
				// 	heroLocation.x -= 10;
				// }
				// if(event.key === 'ArrowRight'){
				// 	console.log('User pressed Right Arrow');
				// 	heroLocation.x += 10;
				// }
			});
			// this is where we will update the hero's position based on keysDown info.
			function update(){
				//User pressedright at some point
				if(32 in keysDown){
					console.log("space!");
					animate();
				}
					
				if(39 in keysDown || 68 in keysDown){
					if(heroLocation.x <= 450){
						heroLocation.x += (10 * speedModifier);
					}
				}
				if(37 in keysDown || 65 in keysDown){
					if(heroLocation.x >= 25){
						heroLocation.x -= (10 * speedModifier);
					}
				}
				if(38 in keysDown || 87 in keysDown){
					if(heroLocation.y >= 25){
						heroLocation.y -= (10 * speedModifier);
					}				
				}
				if(40 in keysDown || 83 in keysDown){
					if(heroLocation.y <= 410){
						heroLocation.y += (10 * speedModifier);
					}		
				}

				// Jittery Monster Movement
				// var chkDirection = Math.floor(Math.random() * 4);
				// if(chkDirection == 0){
				// 	if(monsterLocation.x <= 450){
				// 		(monsterLocation.x += (20 * monsterSpeedModifier)) * (Math.floor((Math.random() * 50) + 28));
				// 	}				
				// }
				// if(chkDirection == 1){
				// 	if(monsterLocation.x >= 25){
				// 		(monsterLocation.x -= (20 * monsterSpeedModifier)) * (Math.floor((Math.random() * 50) + 28));
				// 	}				
				// }
				// if(chkDirection == 2){
				// 	if(monsterLocation.y <= 410){
				// 		(monsterLocation.y += (20 * monsterSpeedModifier)) * (Math.floor((Math.random() * 50) + 28));
				// 	}				
				// }
				// if(chkDirection == 3){
				// 	if(monsterLocation.y >= 25){
				// 		(monsterLocation.y -= (20 * monsterSpeedModifier)) * (Math.floor((Math.random() * 50) + 28));
				// 	}				
				// }



				if(
					(heroLocation.x <= monsterLocation.x + 32)
					&& (heroLocation.y <= monsterLocation.y + 32)
					&& (monsterLocation.x <= heroLocation.x + 32)
					&& (monsterLocation.y <= heroLocation.y + 32)
				){
					// console.log("Hero is left of monster");
					var random = Math.random() * 450;
					var random2 = Math.random() * 400;
					monsterLocation.x = random;
					monsterLocation.y = random2;
					heroLocation.x = 240;
					heroLocation.y = 226;

				}else{
					// console.log("Hero is not close enough");
				}
			}

			// This will handle the monster updates and movement
			function monsterUpdate(){
				if(
					(monsterLocation.newX <= monsterLocation.x + 31)
					&& (monsterLocation.newY <= monsterLocation.y + 31)
					&& (monsterLocation.x <= monsterLocation.newX + 31)
					&& (monsterLocation.y <= monsterLocation.newY + 31)
				){
					monsterLocation.newX = Math.ceil(Math.random() * 450);
					monsterLocation.newY = Math.ceil(Math.random() * 400);
					// console.log("set new location");
				}

				if(monsterLocation.x > monsterLocation.newX){
					monsterLocation.x -= 1 * monsterSpeedModifier;     
				}
				if(monsterLocation.x < monsterLocation.newX){
					monsterLocation.x += 1 * monsterSpeedModifier;
				}
				if(monsterLocation.y > monsterLocation.newY){
					monsterLocation.y -= 1 * monsterSpeedModifier;
				}
				if(monsterLocation.y < monsterLocation.newY){
					monsterLocation.y += 1 * monsterSpeedModifier;
				}

			}

			// This will handle the animation of the sword and the logic of hitting the monster.
			function animateSword(){

				var i = 0;

				function loop(){
					setTimeout(function(){
						i++;
						ctx.clearRect(0, 0, 512, 480);

						drawImageRot(sword, swordLocation.x, swordLocation.y, 32, 32, i);
						loop();
					}, 200)
				}
				function drawImageRot(img,x,y,width,height,deg){
					var rad = deg * Math.PI / 180;
					ctx.translate(x + width / 2, y + height /2);

					ctx.rotate(.5);
					ctx.drawImage(img, width / 2 * (-1), height / 2 * (-1), width, height);
					ctx.rotate(rad * (-1));

					ctx.translate((x + width / 2) * (-1), (y + height / 2) * (-1));
				}
				loop();

			}

			// Keep at the bottom!
			function draw(){
				update();
				monsterUpdate();
				// Put backgroundImage on context at x = 0, y= 0
				context.drawImage(backgroundImage,0,0);
				ctx.drawImage(hero,heroLocation.x,heroLocation.y);
				ctx.drawImage(sword,swordLocation.x,swordLocation.y);
				ctx.drawImage(monster,monsterLocation.x,monsterLocation.y);
				requestAnimationFrame(draw);
			}

			draw();
		</script>
	</div>
	
</div>
</body>
</html>